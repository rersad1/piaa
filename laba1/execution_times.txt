#include <iostream>
#include <vector>
#include <queue>
#include <limits>
#include <functional>
#include <unordered_map>

using namespace std;

const float INF = numeric_limits<float>::max();

struct State {
    vector<vector<float>> costMatrix;
    vector<pair<int, int>> included;
    vector<pair<int, int>> excluded;
    float lowerBound;
    
    State(const vector<vector<float>>& matrix, 
          const vector<pair<int, int>>& inc = {}, 
          const vector<pair<int, int>>& exc = {}, 
          float lb = 0) : costMatrix(matrix), included(inc), excluded(exc), lowerBound(lb) {}
    
    bool operator>(const State& other) const {
        return lowerBound > other.lowerBound;
    }
};

float reduceMatrix(vector<vector<float>>& matrix) {
    int n = matrix.size();
    float reduction = 0;
    
    for (int i = 0; i < n; i++) {
        float minVal = INF;
        for (int j = 0; j < n; j++) {
            if (matrix[i][j] < minVal) {
                minVal = matrix[i][j];
            }
        }
        
        if (minVal > 0 && minVal < INF) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] < INF) {
                    matrix[i][j] -= minVal;
                }
            }
            reduction += minVal;
        }
    }
    
    for (int j = 0; j < n; j++) {
        float minVal = INF;
        for (int i = 0; i < n; i++) {
            if (matrix[i][j] < minVal) {
                minVal = matrix[i][j];
            }
        }
        
        if (minVal > 0 && minVal < INF) {
            for (int i = 0; i < n; i++) {
                if (matrix[i][j] < INF) {
                    matrix[i][j] -= minVal;
                }
            }
            reduction += minVal;
        }
    }
    
    return reduction;
}

pair<int, int> findBranchingEdge(const vector<vector<float>>& matrix) {
    int n = matrix.size();
    float maxCost = -1;
    pair<int, int> edge = {-1, -1};
    
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (matrix[i][j] == 0) {
                float rowMin2 = INF, colMin2 = INF;
                
                for (int k = 0; k < n; k++) {
                    if (k != j && matrix[i][k] < rowMin2)
                        rowMin2 = matrix[i][k];
                    if (k != i && matrix[k][j] < colMin2)
                        colMin2 = matrix[k][j];
                }
                
                if (rowMin2 == INF) rowMin2 = 0;
                if (colMin2 == INF) colMin2 = 0;
                
                float cost = rowMin2 + colMin2;
                if (cost > maxCost) {
                    maxCost = cost;
                    edge = {i, j};
                }
            }
        }
    }
    
    return edge;
}

bool findPath(const vector<pair<int, int>>& edges, 
              int start, int end, vector<int>& path, int n) {
    vector<vector<int>> graph(n);
    for (const auto& edge : edges) {
        graph[edge.first].push_back(edge.second);
    }
    
    vector<bool> visited(n, false);
    function<bool(int, vector<int>&)> dfs = 
        [&](int node, vector<int>& p) -> bool {
            visited[node] = true;
            p.push_back(node);
            
            if (node == end)
                return true;
            
            for (int next : graph[node]) {
                if (!visited[next]) {
                    if (dfs(next, p))
                        return true;
                }
            }
            
            p.pop_back();
            return false;
        };
    
    return dfs(start, path);
}

pair<int, int> findEdgeToExclude(const vector<pair<int, int>>& included, 
                                 int from, int to, int n) {
    if (included.empty()) {
        return {to, from};
    }
    
    vector<pair<int, int>> allEdges = included;
    allEdges.push_back({from, to});
    
    vector<int> path;
    if (findPath(included, to, from, path, n)) {
        return {path[path.size()-1], from};
    }
    
    return {to, from};
}

vector<pair<int, int>> littleAlgorithm(vector<vector<float>> costMatrix) {
    int n = costMatrix.size();
    
    for (int i = 0; i < n; i++) {
        costMatrix[i][i] = INF;
    }
    
    float initialLowerBound = reduceMatrix(costMatrix);
    
    priority_queue<State, vector<State>, greater<State>> pq;
    pq.push(State(costMatrix, {}, {}, initialLowerBound));
    
    while (!pq.empty()) {
        State current = pq.top();
        pq.pop();
        
        if (current.included.size() == n) {
            return current.included;
        }
        
        pair<int, int> edge = findBranchingEdge(current.costMatrix);
        int i = edge.first, j = edge.second;
        
        if (i == -1 || j == -1) continue;
        
        vector<vector<float>> includeMatrix = current.costMatrix;
        vector<pair<int, int>> newIncluded = current.included;
        newIncluded.push_back({i, j});
        
        pair<int, int> excludeEdge = findEdgeToExclude(current.included, i, j, n);
        
        for (int k = 0; k < n; k++) {
            includeMatrix[i][k] = INF;
            includeMatrix[k][j] = INF;
        }
        includeMatrix[j][i] = INF;
        includeMatrix[excludeEdge.first][excludeEdge.second] = INF;
        
        float includeLowerBound = current.lowerBound + reduceMatrix(includeMatrix);
        pq.push(State(includeMatrix, newIncluded, current.excluded, includeLowerBound));
        
        vector<vector<float>> excludeMatrix = current.costMatrix;
        excludeMatrix[i][j] = INF;
        
        float excludeLowerBound = current.lowerBound + reduceMatrix(excludeMatrix);
        vector<pair<int, int>> newExcluded = current.excluded;
        newExcluded.push_back({i, j});
        
        pq.push(State(excludeMatrix, current.included, newExcluded, excludeLowerBound));
    }
    
    return {};
}

vector<int> edgesToPath(const vector<pair<int, int>>& edges, int n) {
    vector<int> path;
    if (edges.empty()) return path;
    
    vector<int> next(n, -1);
    for (const auto& edge : edges) {
        next[edge.first] = edge.second;
    }
    
    int city = 0;
    for (int i = 0; i < n; i++) {
        path.push_back(city);
        city = next[city];
    }
    
    return path;
}

float calculateTotalCost(const vector<int>& path, const vector<vector<float>>& originalCostMatrix) {
    float totalCost = 0;
    int n = path.size();
    
    for (int i = 0; i < n; i++) {
        int from = path[i];
        int to = path[(i + 1) % n];
        totalCost += originalCostMatrix[from][to];
    }
    
    return totalCost;
}

int main() {
    int n;
    cin >> n;
    
    vector<vector<float>> costMatrix(n, vector<float>(n));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> costMatrix[i][j];
            if (costMatrix[i][j] == -1) {
                costMatrix[i][j] = INF;
            }
        }
    }
    
    vector<vector<float>> originalCostMatrix = costMatrix;
    
    vector<pair<int, int>> solution = littleAlgorithm(costMatrix);
    
    if (!solution.empty()) {
        vector<int> path = edgesToPath(solution, n);
        
        for (int i = 0; i < path.size(); i++) {
            cout << path[i];
            if (i < path.size() - 1) cout << " ";
        }
        cout << endl;
        
        float totalCost = calculateTotalCost(path, originalCostMatrix);
        cout << totalCost << endl;
    } 
    else {
        cout << "no path" << endl;
    }
    
    return 0;
}
